Class IrisGraph.Installer
{

/// Main class to import
Parameter CLASS = "IrisGraph.JGW.Parser";

/// Gateway name to create/use
Parameter GATEWAY = "GDB";

/// Path to jar dir.
/// Should have a slash at the end
Parameter DIR As %String = "/opt/app/jars/";

/// Library files to load
Parameter LIBS = {$lb("parser.jar", "eclipse-rdf4j-2.4.2-onejar.jar")};

XData Install [ XMLNamespace = INSTALLER ]
{
<Manifest>
<IfNotDef Var="Namespace">
<Var Name="Namespace" Value="GDB"/>
<Log Text="set namespace to ${Namespace}" Level="0"/>
</IfNotDef>

<If Condition='(##class(Config.Namespaces).Exists("${Namespace}")=0)'>
<Log Text="Creating namespace ${Namespace}" Level="0"/>

<Namespace Name="${Namespace}" Create="yes" Code="${Namespace}" Ensemble="" Data="${Namespace}">
<Log Text="Creating database ${Namespace}" Level="0"/>

<Configuration>
<Database Name="${Namespace}" Dir="${MGRDIR}/${Namespace}" Create="yes" MountRequired="true" Resource="%DB_${Namespace}" PublicPermissions="RW" MountAtStartup="true"/>
</Configuration>

<Log Text="End creating database ${Namespace}" Level="0"/>
</Namespace>

 <Log Text="End creating namespace ${Namespace}" Level="0"/>
</If>

<Namespace Name="${Namespace}" Create="no">
<Log Text="GDB configuration is running" Level="0"/>
<RunInstall Class="IrisGraph.Installer" Method="GDBConfiguration"/>
<Log Text="GDB configuration has been finished" Level="0"/>
</Namespace>

<Namespace Name="${Namespace}" Create="no">
<IfDef Var="SourceDir">
<Log Text="SourceDir defined - offline install from ${SourceDir}" Level="0"/>
<RunInstall Class="IrisGraph.Installer" Method="OfflineInstall"/>
</IfDef>

<IfNotDef Var="SourceDir">
<Log Text="SourceDir undefined - online install from GitHub" Level="0"/>
<RunInstall Class="IrisGraph.Installer" Method="DownloadFromGitHub"/>
</IfNotDef>
</Namespace>
</Manifest>
}

/// This is a method generator whose code is generated by XGL.
/// set pVars("Namespace")="GDB"
/// set pVars("SourceDir")="C:\temp\GDB\"
/// do ##class(IrisGraph.Installer).setup(.pVars)
ClassMethod setup(ByRef pVars, pLogLevel As %Integer = 0, pInstaller As %Installer.Installer) As %Status [ CodeMode = objectgenerator, Internal ]
{
 	Quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "Install")
}

ClassMethod DownloadFromGitHub(pVars, pLogLevel, tInstaller) As %Status
{
    set Namespace = tInstaller.Evaluate("${Namespace}")
    do tInstaller.PushNS("%SYS")
    set tSC = ..Update(Namespace, "intersystems", "iris-graph", "master")
    do tInstaller.PopNS()
    If $$$ISERR(tSC) Throw ##class(%Installer.Exception).CreateFromStatus(tSC)
    quit $$$OK
}

ClassMethod Update(Namespace = {$Namespace}, Owner As %String = "intersystems", Repository As %String = "iris-graph", Branch As %String = "master", Username As %String, Password As %String) As %Status
{
	set namespace = $Namespace
 	set SSLConfig = "GitHub"
 	Zn "%SYS"
 	Do:'##class(Security.SSLConfigs).Exists(SSLConfig) ##class(Security.SSLConfigs).Create(SSLConfig)

 	set req=##class(%Net.HttpRequest).%New()
 	set req.Https=1
	set req.SSLConfiguration=SSLConfig
	set req.Server="api.github.com"
	set req.Location = "repos/" _ Owner _ "/" _ Repository _ "/contents" 	// as described in https://developer.github.com/v3/repos/	
	Do:$d(Branch) req.SetParam("ref",Branch) 								// if omitted the repository’s default branch (usually master) would be used
	do req.SetHeader("Accept","application/vnd.github.v3+json") 			// we want to receive API v3
	
	If ($d(Username) && $d(Password)) {										// supply Username and Passwor, if both are provided. GitHub accept Basic Auth
		set req.Username = Username											// https://developer.github.com/v3/auth/
	 	set req.Password = Password
	} 	
	
 	set links = ##class(%ListOfDataTypes).%New()
 	set st = ..ProcessDirectory("",req,.links)
 	Return:$$$ISERR(st) st
 	 	
 	Zn Namespace
	set st = ..DownloadFiles(links,req,.list)
	set st2 = $system.OBJ.CompileList(.list)
	Zn namespace
	
 	Return $$$ADDSC(st, st2)
}

ClassMethod DownloadFiles(Links As %ListOfDataTypes, Request As %Net.HttpRequest, Output Items) As %Status
{
	Kill Items
	set Request.Server = "raw.githubusercontent.com"
	set st = $$$OK
	
	For i = 1:1:Links.Count() {
		set streq = Request.Get($e(Links.GetAt(i),35,*)) // Remove "https://raw.githubusercontent.com/" from URL.	
		Set:$$$ISERR(streq) st=$$$ADDSC(st, streq)
 		set stload = $system.OBJ.LoadStream(Request.HttpResponse.Data,"",.error,.items)
 		Set:$$$ISERR(stload) st=$$$ADDSC(st, stload)
 		Merge Items = items
	}
	
	set Request.Server="api.github.com"
	Return st
}

ClassMethod ProcessDirectory(Path As %String = "", Request As %Net.HttpRequest, ByRef Links As %ListOfDataTypes) As %Status
{
	set location = Request.Location
	set Request.Location = Request.Location _ Path
	
	set st = Request.Get(,,$$$NO)
	Return:$$$ISERR(st) st
	Return:(Request.HttpResponse.StatusCode = 404) $$$ERROR($$$GeneralError,"Repository doesn't exist OR you don't have access")
	Return:((Request.HttpResponse.StatusCode = 403) && (Request.HttpResponse.GetHeader("X-RATELIMIT-REMAINING")=0)) $$$ERROR($$$GeneralError,"API rate limit exceeded. Try logging in.")
 	Return:(Request.HttpResponse.StatusCode '= 200) $$$ERROR($$$GeneralError,"Received " _ Request.HttpResponse.StatusCode _ " status, expected 200")
 	
 	#dim objects As List of %ZEN.proxyObject
 	#dim obj As %ZEN.proxyObject
	set st = ##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(Request.HttpResponse.Data,,.objects,1)
	Return:$$$ISERR(st) st
	
	For i = 1:1:objects.Count() {		
		set obj = objects.GetAt(i)
		If (obj.type = "dir") {
			set st = ..ProcessDirectory("/"_obj.name,Request,.Links)
			Return:$$$ISERR(st) st		
		} ElseIf (obj.type = "file") {
			Do:..IsCacheFile(obj) Links.Insert(obj."download_url")
		} Else {
			// obj.type = "symlink" or obj.type = "submodule"
		} 
	}
	set Request.Location = location // to keep track of where in the repository tree we are
	Return $$$OK
}

ClassMethod IsCacheFile(File As %ZEN.proxyObject) As %Boolean
{
	set extensions = ",xml,cls,csp,csr,mac,int,bas,inc,gbl,prj,obj,pkg,gof,"
	Return:($L(File.name,".")=1) 0 //no extension
	set File.Extension = $P(File.name,".",$L(File.name,"."))
	Return $F(extensions,","_$ZCVT(File.Extension,"l")_",")
}

ClassMethod OfflineInstall(ByRef pVars, pLogLevel As %Integer = 0, tInstaller As %Installer.Installer) As %Status
{
	set ns = $Namespace
	set namespace = tInstaller.Evaluate("${Namespace}")
	
	zn namespace
	do $system.OBJ.ImportDir(tInstaller.Evaluate("${SourceDir}"),,"ck",.st,1)
	
	zn ns
	quit $$$OK
}

ClassMethod GDBConfiguration(ByRef pVars, pLogLevel As %String, tInstaller As %Installer.Installer) As %Status
{
	set sc = $$$OK
	set Namespace = tInstaller.Evaluate("${Namespace}")
	
	do tInstaller.PushNS("%SYS")

	write $zdt($h,3), " 0 : " ,"Creating web application /"_$ZCONVERT(Namespace, "l"), !
	
	set cspProperties("NameSpace") = Namespace
	set cspProperties("IsNameSpaceDefault") = $$$NO
	set cspProperties("DispatchClass") = "IrisGraph.Sparql.HttpEndpoint"
	set cspProperties("MatchRoles") = ":%All"
	set cspProperties("CookiePath") = "/"
	set sc = ##class(Security.Applications).Create("/", .cspProperties)
	if $$$ISERR(sc) Throw ##class(%Installer.Exception).CreateFromStatus(sc)
	
	write $zdt($h,3), " 0 : " , "Web application / created",!
	
	do tInstaller.PopNS()
	
	do tInstaller.PushNS(Namespace)
	set sc = ..startJGW()
	do tInstaller.PopNS()
	
	Quit sc
}

ClassMethod createGateway(gatewayName = {..#GATEWAY}, javaHome = {$SYSTEM.Util.GetEnviron("JAVA_HOME")}, path As %String = {..getPath()}, port As %Integer = 55551)
{
	set sys = ##class(%Net.Remote.ObjectGateway).%New()
	set sys.Name = gatewayName
	set sys.Type = 1
	set sys.JavaHome = javaHome
	set sys.ClassPath = path
	set sys.Port = port
	quit sys.%Save()
}

/// w ##class(user.Installer).getPath()
ClassMethod getPath()
{
	set separator = $select($$$isWINDOWS:"\",1:"/")
	set path = ""
	for i=1:1:$ll(..#LIBS) {
		set lib = $lg(..#LIBS, i)
		set:$listValid(lib) lib = $lts(lib, separator)
		set path = path _ $lb(..#DIR _ lib)
		
	}
	quit $lts(path)
}

/// Load Jar from path.
/// w $System.Status.GetErrorText(##class(user.Installer).updateJar())
ClassMethod updateJar(gatewayName = {..#GATEWAY}, path As %String = {..getPath()})
{
	
	#Dim sc As %Status = $$$OK
	//set sc = ##class(%Net.Remote.Service).StopGateway(gatewayName)
	//quit:$$$ISERR(sc) sc
	
	#dim gateway As %Net.Remote.Gateway = ..connect(gatewayName, path, .sc)
	quit:$$$ISERR(sc) sc
	
	set sc = gateway.%Import(..#CLASS)

	quit:$$$ISERR(sc) sc
	set:'##class(%Dictionary.CompiledClass).%ExistsId(..#CLASS) sc = $$$ERROR($$$GeneralError, $$$FormatText("Class '%1' does not exist",..#CLASS))
	
	quit sc
}

/// Get JGW object
ClassMethod connect(gatewayName As %String = {..#GATEWAY}, path As %String = {..getPath()}, Output sc As %Status) As %Net.Remote.Gateway
{
	set gateway = ""
	set sc = ##class(%Net.Remote.Service).OpenGateway(gatewayName, .gatewayConfig)
	quit:$$$ISERR(sc) gateway
	set sc = ##class(%Net.Remote.Service).ConnectGateway(gatewayConfig, .gateway, path, $$$YES)
	quit gateway
}

/// w do ##class(user.Installer).startJGW()
ClassMethod startJGW() As %Status
{
	set sc = $$$OK
	
	set sc = ..createGateway()
	quit:$$$ISERR(sc) sc
	
	#dim gateway As %Net.Remote.Gateway = ..connect(,, .sc)
	quit:$$$ISERR(sc) sc
	
	set sc = ..updateJar()
	quit:$$$ISERR(sc) sc
	
	return sc
}

}
